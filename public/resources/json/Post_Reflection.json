{
  "english": [
    { "id": "P_Reflection_Title", "text": "Using Reflection to Generate Code Dynamically" },
	{ "id": "P_Reflection_Part1", "text": "Today, most existing games have a user interface (UI) element displaying a value, a statistic, a quantity, or something else" },
	{ "id": "P_Reflection_Caption1", "text": "Examples of UI used to display information like values to the player. On the left, Digimon Survive (Bandai Namco Ltd. / HYDE), and on the right, Mario Tennis Aces (Nintendo / Camelot Software Planning)." },
	{ "id": "P_Reflection_Part2", "text": "In the same way, anyone developing a game is tasked with doing this, and even though it is a simple task, it quickly becomes redundant, especially when you have a lot of values to display." },
	{ "id": "P_Reflection_Part3", "text": "Following this consideration, I decided to develop a tool that would allow me to simply select a UI element, a value, and link the two, all in a maximum of 2 minutes. So, I started envisioning my UnityBindedGraphics plugin, which will rely on the methods offered by reflection to achieve the intended goals." },
	{ "id": "P_Reflection_Caption2", "text": "UnityBindedGraphics plugin banner." },
	{ "id": "P_Reflection_ImportantPart1", "text": "To clarify the rest of the post, the goal is to present a simple and practical approach to the capabilities of reflection in creating dynamic code through my UnityBindedGraphics (UBG) plugin. This post is not intended to teach you how to handle reflection at an advanced stage but to open a door to what it can do and offer you insight!" },
	{ "id": "P_Reflection_Subtitle1", "text": "What is reflection ?" },
	{ "id": "P_Reflection_Part4", "text": "In programming, reflection is a system that allows an application to modify its own design. The program has the ability to modify its own data, examine them, or perform dynamic operations with the same data." },
	{ "id": "P_Reflection_Part5", "text": "Reflection clearly has significant advantages:"},
	{ "id": "P_Reflection_Flea1", "text": "It offers better code manageability through metadata containers." },
	{ "id": "P_Reflection_Flea2", "text": "It allows dynamic interaction with a class (creation, modification, and invocation) without needing to know the type or have direct access to the class (via an instance, for example)." },
	{ "id": "P_Reflection_Part6", "text": "These qualities make reflection an important tool in many applications, including game engines like Unreal Engine and Unity. Reflection is at the core of several concepts in game engines, such as data saving and loading systems." },
	{ "id": "P_Reflection_Part7", "text": "However, reflection brings along problems that can be tedious to address; we'll come back to this a bit later." },
	{ "id": "P_Reflection_Subtitle2", "text": "Plugin Setup" },
	{ "id": "P_Reflection_Part8", "text": "Now that we understand the utility of reflection in the plugin, it is time to establish a plan. We will also set some constraints to ensure the plugin's smooth operation and simplify its development:" },
	{ "id": "P_Reflection_Flea3", "text": "Since we need a value, it is logical that we only process the members of a class that can return a value." },
	{ "id": "P_Reflection_Flea4", "text": "Regarding methods, only those without arguments will be offered in the editor to streamline the tool's functionality." },
	{ "id": "P_Reflection_Flea5", "text": "However, we will consider both public and private methods, as well as methods belonging to parent classes." },
	{ "id": "P_Reflection_ImportantPart2", "text": "All the code snippets presented have been developed in Unity using C#. Native C++ does not offer a reflection system at the time of writing this article. Nevertheless, the theoretical part covered in this post is common to all programming languages and can be useful to you !" },
	{ "id": "P_Reflection_Part9", "text": "Everything is in place, and we can start developing the plugin. Since reflection is accessible from the System.Reflection library in native C#, we do not need to import any files into Unity." },
	{ "id": "P_Reflection_Subtitle3", "text": "Accessing Class Data Through Reflection" },
	{ "id": "P_Reflection_Part10", "text": "Once the expected behavior of the application is clear, we can start with the first step of the plugin: offering the user the values they can link to a UI element. For this purpose, I have programmed a custom editor where the player can provide a MonoBehaviour component and, in return, receives a list of values they can display. The selected value will be the one displayed when the game launches." },
	{ "id": "P_Reflection_Part11", "text": "To retrieve the list of displayable values, we inspect each property and method member of the class and check that they meet the constraints mentioned earlier. Here is how we proceed with reflection:" },
	{ "id": "P_Reflection_Flea6", "text": "We get the type of the component passed as a parameter in the custom editor using the GetType() extension method, which returns the class's type and all related metadata." },
	{ "id": "P_Reflection_Flea7", "text": "From the type, we can call GetMethods(BindingsFlags), which returns a list of methods present in the data type making the call. The BindingsFlags is an enumeration that allows us to filter which methods we want to retrieve (public, private methods, etc)." },
	{ "id": "P_Reflection_Flea8", "text": "We apply the same principle to properties with GetProperties(BindingsFlags)." },
	{ "id": "P_Reflection_Flea9", "text": "We can then display the available values based on their names using the 'name' variable." },
	{ "id": "P_Reflection_ImportantPart3", "text": "It is important to note that, just like the Type class, which contains all the metadata for a given type, there are metadata containers for each type of member: FieldInfo, PropertyInfo, MethodInfo, etc. The parent class for member metadata containers is MemberInfo." },
	{ "id": "P_Reflection_Part12", "text": "To simplify the display of available values, I group PropertyInfo and MethodInfo under the MemberInfo class, resulting in the following:" },
	{ "id": "P_Reflection_Caption3", "text": "The obtained values are displayed by their name in the 'Member to bind' dropdown list." },
	{ "id": "P_Reflection_Subtitle4", "text": "Dynamically Calling a Method Using Reflection" },
	{ "id": "P_Reflection_Part13", "text": "At this point, we have a custom editor that uses reflection to retrieve valid values to provide to our UI. So, we can now move on to the second phase of the project: linking the value to our UI element at the game's launch."},
	{ "id": "P_Reflection_Part14", "text": "If we want, we can do this quite easily with the Invoke(object, object[]) method of the MethodInfo class. This method allows us to execute any function without knowing its type. We just need to provide it with the calling instance and the required arguments, and it is done." },
	{ "id": "P_Reflection_Part15", "text": "So, here are the steps:" },
	{ "id": "P_Reflection_Flea10", "text": "We obtain our metadata container in the form of a MemberInfo." },
	{ "id": "P_Reflection_Flea11", "text": "From it, we extract the method that returns our value to display, whether it is a MethodInfo for a class or a GetMethod for a PropertyInfo." },
	{ "id": "P_Reflection_Flea12", "text": "We execute the return method via Invoke, and we display the value in the UI." },
	{ "id": "P_Reflection_Part16", "text": "If our UI element is a text, the final rendering would be:" },
	{ "id": "P_Reflection_ImportantPart4", "text": "ExtractGetMethod and the static class ReflectionUtils are small utilities that I have developed and do not belong to the System.Reflection library. The operation of ExtractGetMethod is not complicated; it involves a simple valid cast check, and if successful, I extract the necessary method as indicated earlier." },
	{ "id": "P_Reflection_Part17", "text": "As we can see, it is straightforward to call a method dynamically through reflection. However, in the case of UnityBindedGraphics, which may have multiple UI elements simultaneously linked to a value and regular updates of the value, this can be detrimental to performance." },
	{ "id": "P_Reflection_Subtitle5", "text": "The drawbacks of Reflection" },
	{ "id": "P_Reflection_Part18", "text": "Let's go back to the drawbacks of reflection, as I mentioned earlier. In fact, the biggest drawback of reflection is also what gives it its strength: the data type we are interacting with is unknown at compile time." },
	{ "id": "P_Reflection_Part19", "text": "This unique feature of the system is also its weakness because it brings new challenges that we encounter less often in normal circumstances"},
	{ "id": "P_Reflection_Flea13", "text": "Reflection requires more security when dealing with data since we do not know what type we are working with and what can be done with it." },
	{ "id": "P_Reflection_Flea14", "text": "Calling methods via reflection requires determining the method, the method's declaring type, and the 'instigator' object's type for the invocation, not to mention the unknown arguments; in short, everything must be determined at runtime." },
	{ "id": "P_Reflection_Flea15", "text": "Reflection promotes the boxing and unboxing of values." },
	{ "id": "P_Reflection_Flea16", "text": "The compiler can perform very few optimizations and checks on method calls." },
	{ "id": "P_Reflection_ImportantPart5", "text": "Boxing and unboxing are conversions of a value type, like int, into an object type or an interface type that the value type implements. These are costly conversion operations that require allocating memory for a new object instance on the heap, you can find more information on boxing/unboxing here." },
	{ "id": "P_Reflection_Part20", "text": "Considering all of this, it quickly becomes a challenge for both us and the compiler to work with the reflection system. That's why we'll use a delegate to store the method that returns the value and call it without resorting to reflection." },
	{ "id": "P_Reflection_Part21", "text": "But two issues arise: the user determines the type of our value, and we need to create this delegate at the game's launch. So, first, we'll look into dynamically creating the method that will create the delegate, and then we'll figure out how to dynamically create this delegate."},
	{ "id": "P_Reflection_Subtitle6", "text": "Dynamically create a generic method using reflection." },
	{ "id": "P_Reflection_Part22", "text": "To allow the plugin user to customize the delegate's behavior, we will create an interface IRefValueWrapper and a generic class RefValueContainer<TValueType> that will contain this delegate." },
	{ "id": "P_Reflection_Part23", "text": "Now let's revisit the first problem with this approach: the user determines the type of our value. Assuming our value is of type int, we would need to dynamically execute the following instruction:" },
	{ "id": "P_Reflection_Part24", "text": "For this, reflection will help us again. In the System.Reflection library, there is a function MakeGenericMethod(Type[]). This method belongs to the MethodInfo class and takes an array of Types as parameters to return a new MethodInfo with the same definition as the initiating MethodInfo but with the desired types as parameters. Here's a much clearer example, assuming our value is of type int:" },
	{ "id": "P_Reflection_ImportantPart6", "text": "Although MakeGenericMethod(Type[]) is a very powerful function, it can easily cause an exception because we are creating a generic method dynamically that is completely unknown to the compiler. So, be sure to secure your code when using this function." },
	{ "id": "P_Reflection_Part25", "text": "We now have a way to dynamically create our generic method that will pass the value's type to the delegate. All that's left is to find a way to dynamically create our delegate" },
	{ "id": "P_Reflection_ImportantPart7", "text": "It's important to note that there are also other functions that allow you to create a type, a constructor, and more from a generic definition." },
	{ "id": "P_Reflection_Subtitle7", "text": "Dynamically create a delegate using reflection." },
	{ "id": "P_Reflection_Part26", "text": "We are getting closer to our goal, we need to find a way to dynamically create our delegate." },
	{ "id": "P_Reflection_Part27", "text": "If we delve into the System.Reflection documentation, we can find the CreateDelegate function." },
	{ "id": "P_Reflection_Part28", "text": "There are several overloads of this method, but we will use this one because it is the method we will link to an instantiated method." },
	{ "id": "P_Reflection_ImportantPart8", "text": "We will only deal with instance methods in our case because we have a reference to the component that has the method that returns the value. However, know that it is possible to create delegates for static methods as well." },
	{ "id": "P_Reflection_Part29", "text": "Now that we have a solution for each of our problems, we can propose a solution for updating our UI when our value changes dynamically; here is the result:" },
	{ "id": "P_Reflection_ImportantPart9", "text": "Here, memberValue corresponds to our previously retrieved MemberInfo, and selectedType is the type of the value we want to display." },
	{ "id": "P_Reflection_Part30", "text": "To give the user the choice of how to update the value in the UI, we will offer an update through Unity's Update method or via a delegate that will also be dynamically created (in the same way as in the example just above)." },
	{ "id": "P_Reflection_Part31", "text": "Finally, we are done. The plugin allows us to select a value to display, and in the game, it dynamically manages the display of our value in the UI. Our new solution allows updates that take 0.004ms to 0.012ms depending on the type of UI, which is quite good." },
	{ "id": "P_Reflection_Part32", "text": "This is where this post concludes. Reflection allows for deep manipulation of types, and I think this article has shown you the basics for creating many cool tools. Perhaps reflection has inspired you to create new tools ?" }
  ],
  "french": [
    { "id": "P_Reflection_Title", "text": "Utiliser la réflexion pour produire du code dynamiquement." },
	{ "id": "P_Reflection_Part1", "text": "Aujourd’hui, la plupart des jeux existants possède un élément d’IU (interface utilisateur) affichant une valeur une statistique ou une quantité, ou encore autre chose. " },
	{ "id": "P_Reflection_Caption1", "text": "Exemple d’IU utilisées pour afficher des informations comme des valeurs au joueur. À gauche DigimonSurvive (Bandai Namco Ltd. / HYDE), à droite Mario Tennis Aces (Nintendo / Camelot Software Planning. " },
	{ "id": "P_Reflection_Part2", "text": "De la même manière, n’importe qui développant un jeu est amené à réaliser cela, et même si c’est une tâche simple, elle devient vite redondante, surtout quand on a énormément de valeurs à afficher. " },
	{ "id": "P_Reflection_Part3", "text": "Suite à cette réflexion, j’ai décidé de programmer un outil me permettant de simplement sélectionner un élément d’IU, une valeur, et de relier les deux, le tout en 2 minutes maximum. J’ai donc commencé à imaginer mon plugin UnityBindedGraphics qui va s’appuyer sur les méthodes que propose la réflexion afin d’atteindre les objectifs escomptés. " },
	{ "id": "P_Reflection_Caption2", "text": "Bannière du plugin UnityBindedGraphics." },
	{ "id": "P_Reflection_ImportantPart1", "text": "Afin de clarifier la suite du post, le but est de présenter une approche simple et concrète des capacités de la réflexion dans la création de code dynamique au travers de mon plugin UnityBindedGraphics (UBG).\n Ce post n’a donc pas pour but de vous apprendre à manier la réflexion dans son intégralité mais de vous ouvrir une porte vers ce qu’elle peut faire et vous proposez, notamment dans le framwork .NET ! " },
	{ "id": "P_Reflection_Subtitle1", "text": "Qu’est-ce que la réflexion ? " },
	{ "id": "P_Reflection_Part4", "text": "La réflexion est un système permettant à une application de pouvoir modifier la conception ou le comportement d'un autre programme. Le programme réfléxive a la capacité de modifier les données d'un autre programme ou ses propres données, de les examiner ou encore d’effectuer des opérations dynamiques avec ses données. Concernant la réflexion dans .NET, je vous invite à lire cette page : " },
	{ "id": "P_Reflection_Part5", "text": "La réflexion a clairement des avantages qui ne sont pas négligeables :" },
	{ "id": "P_Reflection_Flea1", "text": "Elle offre une meilleure maniabilité d’un code grâce à des conteneurs de métadonnées." },
	{ "id": "P_Reflection_Flea2", "text": "Elle permet d’interagir dynamiquement avec une classe (création, modification et appel) sans avoir besoin de connaître le type ou de posséder un accès direct à la classe (via une instance par exemple). " },
	{ "id": "P_Reflection_Part6", "text": "Ce sont ses qualités qui font que la réflexion est un outil aussi important dans des tas d’application, dont les moteurs de jeux comme l’Unreal Engine et Unity. La réflexion est au cœur de plusieurs concepts dans les moteurs de jeux comme les systèmes de sauvegarde et de chargement de données. " },
	{ "id": "P_Reflection_Part7", "text": "Néanmoins, la réflexion entraîne des problèmes qui peuvent être fastidieux à régler, nous reviendrons dessus un peu plus tard. " },
	{ "id": "P_Reflection_Subtitle2", "text": "Setup du plugin " },
	{ "id": "P_Reflection_Part8", "text": "Maintenant que nous savons l’utilité de la réflexion dans le plugin, il est temps d’établir un plan. On va aussi poser des contraintes afin d’assurer le bon fonctionnement du plugin et simplifier son développement : " },
	{ "id": "P_Reflection_Flea3", "text": "Étant donné qu'il nous faut une valeur, il est logique qu’on traite seulement les membres d’une classe qui peuvent retourner une valeur." },
	{ "id": "P_Reflection_Flea4", "text": "Concernant les méthodes, seuls celles ne contenant pas d’argument seront proposés dans l’éditeur afin de simplifier le fonctionnement de l’outil." },
	{ "id": "P_Reflection_Flea5", "text": "Nous allons par contre prendre en compte aussi bien les méthodes publics que les méthodes privates ou encore les méthodes propres à des classes parents. " },
	{ "id": "P_Reflection_ImportantPart2", "text": "L'intégralité des extraits de code présentés ont été développés sous Unity en C#.\n  Le C++ natif ne propose pas de système de réflexion au moment où j’écris cet article néanmoins, la partie théorique abordé dans ce post est commune à l’ensemble des langages de programmation et peut donc vous être utiles !" },
	{ "id": "P_Reflection_Part9", "text": "Tout est en place, on peut commencer le développement du plugin. Comme la réflexion est accessible depuis la bibliothèque System.Reflection en C# natif, nous n’avons pas besoin d’importer le moindre fichier sur Unity." },
	{ "id": "P_Reflection_Subtitle3", "text": "L’accès aux données d’une classe par réflexion" },
	{ "id": "P_Reflection_Part10", "text": "Une fois le comportement attendu de l’application mis au clair, on peut commencer la première étape du plugin : proposer à l’utilisateur les valeurs qu’il peut relier à un élément d’IU. Pour cela, j’ai programmé un éditeur custom où le joueur peut donner un composant MonoBehaviour et reçoit en retour une liste de valeur qu’il peut afficher, la valeur sélectionnée sera donc la valeur affichée au lancement du jeu." },
	{ "id": "P_Reflection_Part11", "text": "Pour récupérer la liste des valeurs pouvant être affichés, on va inspecter chaque membre propriétés et méthodes de la classe et vérifier qu’ils respectent les contraintes évoquées précédemment. Avec la réflexion, voici comment on procède :" },
	{ "id": "P_Reflection_Flea6", "text": "On récupère le type du composant passé en paramètre dans l’éditeur personnalisé avec la méthode d’extension GetType() qui retourne le type de la classe et toutes les métadonnées liées à cette classe." },
	{ "id": "P_Reflection_Flea7", "text": "Depuis le type, on peut appeler GetMethods(BindingsFlags) qui va nous retourner une liste de méthodes présentes dans le type de données qui fait l’appel. Les BindingsFlags sont une énumération nous permettant de filtrer quelles méthodes on souhaite récupérer (méthodes public, private etc)." },
	{ "id": "P_Reflection_Flea8", "text": "On applique le même principe pour les propriétés avec GetProperties(BindingsFlags)." },
	{ "id": "P_Reflection_Flea9", "text": "On peut ensuite afficher les valeurs disponibles à partir de leur nom via la variable name." },
	{ "id": "P_Reflection_ImportantPart3", "text": "Il est important de noter que comme pour la classe Type qui contient toutes les métadonnées d’un type donnée, il existe des conteneurs de métadonnées pour chaque type de membre : FieldInfo, PropertyInfo, MethodInfo etc.\n La classe mère de conteneurs de métadonnées d’un membre est MemberInfo : " },
	{ "id": "P_Reflection_Part12", "text": "Pour simplifier l’affichage des valeurs disponibles, je regroupe les PropertyInfo et les MethodInfo sous la classe MemberInfo, on obtient ainsi le résultat suivant :" },
	{ "id": "P_Reflection_Caption3", "text": "Les valeurs que nous avons obtenues sont affichés par leur nom dans la liste déroulante “Member to bind”." },
	{ "id": "P_Reflection_Subtitle4", "text": "Appeler dynamiquement une méthode avec la réflexion" },
	{ "id": "P_Reflection_Part13", "text": "À ce stade, on a un éditeur personnalisé qui utilise la réflexion pour récupérer des valeurs valides à donner à notre IU. On peut donc aborder la deuxième étape du projet : relier la valeur à notre élément d’IU au lancement du jeu."},
	{ "id": "P_Reflection_Part14", "text": "Si on veut, on peut faire cela très simplement avec la méthode Invoke(object, object[]) de la classe MethodInfo. Cette méthode permet d’exécuter n’importe quelle fonction sans connaître son type, on a juste à lui fournir l’instance qui appelle cette méthode étant donné et le tour est joué" },
	{ "id": "P_Reflection_Part15", "text": "Voilà donc les étapes :" },
	{ "id": "P_Reflection_Flea10", "text": "On obtient notre conteneur de métadonnées sous la forme d’un MemberInfo." },
	{ "id": "P_Reflection_Flea11", "text": "On en extrait la méthode qui retourne notre value à afficher, c’est-à-dire la méthode en elle-même s’il s’agit d’une classe MethodInfo, sinon la GetMethod pour un PropertyInfo" },
	{ "id": "P_Reflection_Flea12", "text": "On exécute la méthode de retour via Invoke et on affiche la valeur dans l’IU." },
	{ "id": "P_Reflection_Part16", "text": "Si notre élément d’IU est un texte, le rendu final serait :" },
	{ "id": "P_Reflection_ImportantPart4", "text": "ExtractGetMethod et la classe statique ReflectionUtils sont des petits utilitaires que j’ai développés et n’appartienne donc pas à la bibliothèque System.Reflection.\n Le fonctionnement d’ExtractGetMethod n’est pas pour autant compliqué, il s’agit d’une simple vérification de cast valide et le cas échéant, j’extrais la méthode qu’il me faut comme indiqué précédemment." },
	{ "id": "P_Reflection_Part17", "text": "Comme on peut le constater, il est très simple d’appeler une méthode dynamiquement par réflexion, seulement dans le cas d’UnityBindedGraphics qui risque d’avoir simultanément plusieurs UI relié à une valeur et des mises à jour régulières de la valeur, c’est mauvais pour les performances." },
	{ "id": "P_Reflection_Subtitle5", "text": "Les défauts de la réflexion" },
	{ "id": "P_Reflection_Part18", "text": "On revient sur les défauts de la réflexion comme je l’avais évoqué plus haut. En fait, le plus gros défaut de la réflexion est en même temps ce qui fait sa force : le type de données avec lequel on interagit est inconnu à la compilation." },
	{ "id": "P_Reflection_Part19", "text": "Cette particularité de ce système est aussi sa faiblesse car cela apporte des nouvelles problématiques qu’on rencontre moins souvent en temps normal :" },
	{ "id": "P_Reflection_Flea13", "text": "La réflexion nécessite plus de sécurité lors du traitement d’une donnée puisqu’on ne sait pas avec quel type on travaille et ce qu’on peut faire avec" },
	{ "id": "P_Reflection_Flea14", "text": "L’appel de méthodes via la réflexion nécessite de déterminer la méthode et le type déclarant la méthode ainsi que celui de l’objet “instigateur” de l’invocation, sans compter les arguments qui sont inconnus, bref il faut tout déterminer à l’exécution." },
	{ "id": "P_Reflection_Flea15", "text": "La réflexion favorise le boxing et l’unboxing de valeurs" },
	{ "id": "P_Reflection_Flea16", "text": "Le compilateur ne peut effectuer que très peu d’optimisation et de vérification sur l’appel de la méthode" },
	{ "id": "P_Reflection_ImportantPart5", "text": "Le boxing et l’unboxing sont une conversion d’un type valeur comme int en un type object ou en type interface qu’implémente le type valeur en question.\nCe sont des opérations de conversions coûteuses et qui nécessite d’allouer de la mémoire pour une nouvelle instance d’objet dans le tas, retrouvez-plus d’information sur le boxing / l’unboxing " },
	{ "id": "P_Reflection_Part20", "text": "En prenant tout ça en compte, ça devient vite un chantier aussi bien pour nous que pour le compilateur de travailler avec le système de réflexion. C’est pour ça que nous allons utiliser un delegate pour stocker la méthode qui renvoie la valeur et ainsi l’appeler sans avoir recours à la réflexion." },
	{ "id": "P_Reflection_Part21", "text": "Mais deux soucis se posent, c’est l’utilisateur qui détermine le type de notre valeur et il faut créer ce delegate au lancement du jeu, on va donc chercher d’abord à pouvoir créer dynamiquement notre méthode qui va créer le delegate, puis on verra ensuite comment crée dynamiquement ce delegate." },
	{ "id": "P_Reflection_Subtitle6", "text": "Créer dynamiquement une méthode générique avec la réflexion" },
	{ "id": "P_Reflection_Part22", "text": "Pour permettre à l'utilisateur du plugin de personnaliser le comportement du delegate, nous allons créer une interface IRefValueWrapper et une classe générique RefValueContainer<TValueType> qui vont contenir ce delegate." },
	{ "id": "P_Reflection_Part23", "text": "Maintenant revenons sur le premier problème de cette approche : c’est l’utilisateur qui détermine le type de notre valeur. En imaginant que notre valeur est de type int, il faudrait donc qu’on puisse faire dynamiquement l’instruction suivante :" },
	{ "id": "P_Reflection_Part24", "text": "Pour cela, la réflexion va nous aider à nouveau, il existe dans la bibliothèque System.Reflection une fonction MakeGenericMethod(Type[]). Cette méthode appartient à la classe MethodInfo et prend un tableau de Type en paramètres afin de retourner un nouveau MethodInfo, avec la même définition que le MethodInfo instigateur mais avec les types souhaités en paramètre. Voilà un exemple bien plus parlant en supposant que notre valeur est de type int :" },
	{ "id": "P_Reflection_ImportantPart6", "text": "Même si MakeGenericMethod(Type[]) est une fonction très puissante, elle peut facilement causer une exception du fait qu’on crée une méthode générique dynamiquement et qui est totalement inconnu au compilateur, faîtes donc attention à bien sécuriser votre code quand vous faîtes appel à cette fonction." },
	{ "id": "P_Reflection_Part25", "text": "On a désormais un moyen de créer dynamiquement notre méthode générique qui va passer au delegate le type de la valeur, il ne nous reste plus qu’à trouver un moyen de créer dynamiquement notre delegate." },
	{ "id": "P_Reflection_ImportantPart7", "text": "Il est important de noter qu’il existe aussi une autre fonction permettant de créer un type depuis une définition générique, on pourrait par exemple créer une List<int> depuis List<T0> avec cette méthode. Pour en savoir plus : " },
	{ "id": "P_Reflection_Subtitle7", "text": "Créer dynamiquement un delegate avec la réflexion " },
	{ "id": "P_Reflection_Part26", "text": "On approche du but, il faut trouver un moyen de créer dynamiquement notre delegate." },
	{ "id": "P_Reflection_Part27", "text": "Si on fouille la documentation de System.Reflection, on peut trouver la fonction CreateDelegate : " },
	{ "id": "P_Reflection_Part28", "text": "Il existe plusieurs surcharges de cette méthode mais on va utiliser celle-ci parce que la méthode que nous allons relier une méthode instanciée." },
	{ "id": "P_Reflection_ImportantPart8", "text": "Nous n’allons traiter que les méthodes instanciées dans notre cas puisque nous avons une référence vers le composant possédant la méthode qui renvoi la valeur.\n Néanmoins, sachez qu’il est possible de créer des delegates pour des méthodes statiques également." },
	{ "id": "P_Reflection_Part29", "text": "Maintenant qu’on a une solution pour chacun de nos problèmes, on peut proposer une solution pour mettre à jour notre IU lorsque notre valeur change dynamiquement, volà le résultat :" },
	{ "id": "P_Reflection_ImportantPart9", "text": "Ici, memberValue correspond à notre MemberInfo récupéré plutôt et selectedType est le type de la valeur que l’on souhaite afficher." },
	{ "id": "P_Reflection_Part30", "text": "Afin de laisser le choix à l’utilisateur sur comment mettre à jour la valeur dans l’IU, nous allons proposer la mise à jour par la méthode Update d’Unity ou via un delegate qui sera lui aussi crée dynamiquement (de la même manière que dans l’exemple juste au-dessus)." },
	{ "id": "P_Reflection_Part31", "text": "Enfin, nous avons fini, le plugin nous permet de sélectionner une valeur à afficher, puis en jeu, il gère dynamiquement l’affichage de notre valeur dans l’IU. Notre nouvelle solution permet de faire des updates qui prennent 0.004ms allant à 0.012ms en fonction du type d’IU, ce qui est franchement pas mal." },
	{ "id": "P_Reflection_Part32", "text": "C'est ici que se conclut ce post. La réflexion permet de manipuler en profondeur les types et je pense que cet article vous a montré les bases pour faire beaucoup d'outils sympa avec. Peut-être même que la réflexion vous a inspiré à créer de nouveaux outils ?" }
  ]
}